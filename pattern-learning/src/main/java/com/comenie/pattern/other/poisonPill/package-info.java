/**
 * Created by 波 on 2017/2/9.
 */
package com.comenie.pattern.other.poisonPill;
/**
 * 毒丸设计模式：
 * 生产者、消费者模式是多线程中的经典问题。通过中间的缓冲队列，使得生产者和消费者的速度可以相互调节。
 * 对于比较常见的单生产者、多消费者的情况，主要有以下两种策略：通过volatile boolean producerDone ＝false 来标示是否完成。
 * 生产者结束后标示为true, 消费者轮询这个变量来决定自己是否退出。
 * 这种方式对producerDone产生比较大的争用，实现起来也有诸多问题需要考虑。
 * 比较经典的“毒丸”策略，生产者结束后，把一个特别的对象：“毒丸”对象放入队列。消费者从队列中拿到对象后，判断是否是毒丸对象。
 * 如果是普通非毒丸对象，则正常消费。如果是毒丸对象，则放回队列（杀死其他消费者），然后结束自己。
 * 这种方式不会对结束状态产生争用，是比较好的方式。由于“毒丸”策略是在单生产者多消费者情况下的
 * 。对于多生产者的情况，需要对之进行一些修改。我的想法是这样的。用Countdownlatch作为生产者计数器。
 * 所有生产者结束后，由协调者放入毒丸对象，消费者退出过程是一样的。
 * 上代码：Coordinator: 启动生产者消费者，提供队列、计数器。生产者全部结束后，放入毒丸。
 */

